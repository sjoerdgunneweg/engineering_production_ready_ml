{"version":3,"file":"768.js?_cache=10c4338cfa5ec24acf8b","mappings":"uTAwBA,SAASA,EAAoBC,GAE3B,MAAMC,EAAQD,EAAWC,MAAM,mBAC/B,OAAOA,EAAQA,EAAM,GAAKD,CAC5B,CAqBA,MA2EA,EA3EoC,EAClCE,QACAC,eACAC,aACAC,aACAC,oBAEA,MAAOC,IAASC,EAAAA,EAAAA,KACVC,GAAUC,EAAAA,EAAAA,SAAO,GAEjBC,EAAmBL,GAAiBA,EAAcM,OAAS,GAEjEC,EAAAA,EAAAA,WAAU,KACHJ,EAAQK,UACXL,EAAQK,SAAU,GAClBC,EAAAA,EAAAA,GAAqB,2BAA4B,CAAEC,UAAW,qCAE/D,IAEH,MAAMC,GAAoBC,EAAAA,EAAAA,IAAiBhB,GAG3C,IAAIiB,EACAC,EAEJ,GAAIT,EAIFS,EAAiBd,EAAc,GAAGe,OAAOC,IAAKC,IAAUC,EAAAA,EAAAA,IAA0BD,QAC7E,KAAIN,EAKJ,CACL,MAAMQ,EAAM,IAAIC,MAAM,0DAEtB,OADAC,EAAAA,EAAOpB,MAAMkB,EAAK,CAAEvB,UACb,kBAAC0B,EAAAA,EAASA,CAACrB,MAAOkB,GAC3B,CANEN,EAASF,EAAkBE,OAC3BC,EAAiBH,EAAkBI,OAAOC,IAAKC,IAAUC,EAAAA,EAAAA,IAA0BD,GAKrF,CAIA,MAAMM,EAAoB,CAAC,UAAW,UAChCC,EAAuBnB,EA5D/B,SAA+BoB,GAC7B,MAAMC,EAAW,IAAIC,IAAIF,EAAYT,IAAIvB,IACzC,OAAOmC,MAAMC,KAAKH,EACpB,CA0DMI,CAAsB9B,EAAcgB,IAAKe,GAAMA,EAAErC,aAAasC,OAAQnB,GACpEU,EAAkBU,MAAOC,IAAoBrB,EAAOsB,WAAWD,UAEjEE,EAIJ,GAAIZ,aAAAA,EAAAA,EAAsBlB,OAAQ,CAChC,MAAM+B,EAAiB,GAAGC,EAAAA,MAA0BC,EAAAA,EAAcC,SAClEC,EAAAA,gBAAgBC,QAAQ,CAAE,CAACL,GAAiBb,EAAqBmB,KAAK,OAAQ,GAE9E,MAAMC,EAAiB,GAAGN,EAAAA,UAA8BO,EAAAA,KACxDJ,EAAAA,gBAAgBC,QAAQ,CAAE,CAACE,GAAiB,iBAAkB,EAChE,CAEA,MAAME,GAAQC,EAAAA,EAAAA,IAAgB,CAC5BlC,SACAmC,UAAWjD,EAAWkD,IACtBnC,iBACAoC,YAAYC,EAAAA,EAAAA,GAAiBtD,EAAcC,GAC3CsD,UAAU,IAGZ,OACE,kBAACC,MAAAA,CAAIC,cAAY,8CACdrD,EAAQ,kBAACqB,EAAAA,EAASA,CAACrB,MAAOA,IAAY,kBAACsD,EAAAA,EAAKA,CAACT,MAAOA,K,0DClG3D,SAASU,EAAYC,GACnB,MAAoB,iBAATA,GAAqBC,EAAAA,SAASC,aAAaF,GAE7CA,EAGFC,EAAAA,SAASE,WAAW,IAAIC,KAAKJ,GAAO,CAAEK,SAAS,IAAUC,aAClE,CAwBO,SAASZ,EAAiBtB,EAAiCmC,GAChE,OAAO,IAAIC,EAAAA,eAAe,CAAEpC,KAAM2B,EAAY3B,GAAOmC,GAAIR,EAAYQ,IACvE,C","sources":["webpack://grafana-metricsdrilldown-app/./exposedComponents/SourceMetrics/SourceMetrics.tsx","webpack://grafana-metricsdrilldown-app/./shared/utils/utils.timerange.ts"],"sourcesContent":["import { type AdHocVariableFilter, type DataSourceApi } from '@grafana/data';\nimport { locationService } from '@grafana/runtime';\nimport React, { useEffect, useRef } from 'react';\n\nimport { ErrorView } from 'App/ErrorView';\nimport { Trail } from 'App/Routes';\nimport { useCatchExceptions } from 'App/useCatchExceptions';\nimport { VAR_WINGMAN_SORT_BY } from 'MetricsReducer/list-controls/MetricsSorter/MetricsSorter';\nimport { metricFilters } from 'MetricsReducer/SideBar/SideBar';\nimport { logger } from 'shared/logger/logger';\nimport { reportExploreMetrics } from 'shared/tracking/interactions';\nimport { embeddedTrailNamespace, newMetricsTrail } from 'shared/utils/utils';\nimport { labelMatcherToAdHocFilter } from 'shared/utils/utils.variables';\n\nimport { parsePromQLQuery } from '../../extensions/links';\nimport { type PromQLLabelMatcher } from '../../shared/utils/utils.promql';\nimport { toSceneTimeRange } from '../../shared/utils/utils.timerange';\n\n/**\n * Extracts the prefix from a Prometheus metric name.\n * The prefix is the first part of the metric name before any separator (underscore or colon).\n * Example: \"grafana_slo_threshold_expression\" → \"grafana\"\n *          \"traces_spanmetrics_calls_total\" → \"traces\"\n */\nfunction extractMetricPrefix(metricName: string): string {\n  // Match up to the first non-alphanumeric character (typically underscore or colon)\n  const match = metricName.match(/^([a-zA-Z0-9]+)/);\n  return match ? match[1] : metricName;\n}\n\n/**\n * Extracts unique prefixes from an array of metric names.\n */\nfunction extractUniquePrefixes(metricNames: string[]): string[] {\n  const prefixes = new Set(metricNames.map(extractMetricPrefix));\n  return Array.from(prefixes);\n}\n\nexport interface SourceMetricsProps {\n  query: string;\n  initialStart: string | number;\n  initialEnd: string | number;\n  dataSource: DataSourceApi;\n  sourceMetrics?: Array<{\n    metricName: string;\n    labels: PromQLLabelMatcher[];\n  }>;\n}\n\nconst KnowledgeGraphSourceMetrics = ({\n  query,\n  initialStart,\n  initialEnd,\n  dataSource,\n  sourceMetrics,\n}: SourceMetricsProps) => {\n  const [error] = useCatchExceptions();\n  const initRef = useRef(false);\n\n  const hasSourceMetrics = sourceMetrics && sourceMetrics.length > 0;\n\n  useEffect(() => {\n    if (!initRef.current) {\n      initRef.current = true;\n      reportExploreMetrics('exposed_component_viewed', { component: 'knowledge_graph_source_metrics' });\n    }\n  }, []);\n\n  const parsedPromQLQuery = parsePromQLQuery(query);\n\n  // Determine metric and filters based on data source\n  let metric: string | undefined;\n  let initialFilters: AdHocVariableFilter[] | undefined;\n\n  if (hasSourceMetrics) {\n    // When sourceMetrics are provided, don't set a metric.\n    // This ensure that the MetricsReducer is shown, allowing\n    // users to select from the filtered list of metrics.\n    initialFilters = sourceMetrics[0].labels.map((label) => labelMatcherToAdHocFilter(label));\n  } else if (parsedPromQLQuery) {\n    // When sourceMetrics aren't provided, fall back to\n    // selecting the metric from the provided PromQL query.\n    metric = parsedPromQLQuery.metric;\n    initialFilters = parsedPromQLQuery.labels.map((label) => labelMatcherToAdHocFilter(label));\n  } else {\n    const err = new Error('Missing metric information for Knowledge Graph insight');\n    logger.error(err, { query });\n    return <ErrorView error={err} />;\n  }\n\n  // Extract unique prefixes from sourceMetrics to filter the metrics list\n  // This naturally excludes metrics like \"asserts_*\" and \"ALERTS*\" that aren't in sourceMetrics\n  const prefixesToExclude = ['asserts', 'ALERTS'];\n  const sourceMetricPrefixes = hasSourceMetrics\n    ? extractUniquePrefixes(sourceMetrics.map((m) => m.metricName)).filter((metric) =>\n        prefixesToExclude.every((excludedPrefix) => !metric.startsWith(excludedPrefix))\n      )\n    : undefined;\n\n  // Set URL params for prefix filters BEFORE creating the trail\n  // This leverages Scenes' built-in URL sync in MetricsFilterSection\n  if (sourceMetricPrefixes?.length) {\n    const prefixUrlParam = `${embeddedTrailNamespace}-${metricFilters.prefix}`;\n    locationService.partial({ [prefixUrlParam]: sourceMetricPrefixes.join(',') }, true);\n\n    const sortByUrlParam = `${embeddedTrailNamespace}-var-${VAR_WINGMAN_SORT_BY}`;\n    locationService.partial({ [sortByUrlParam]: 'alphabetical' }, true);\n  }\n\n  const trail = newMetricsTrail({\n    metric,\n    initialDS: dataSource.uid,\n    initialFilters,\n    $timeRange: toSceneTimeRange(initialStart, initialEnd),\n    embedded: true,\n  });\n\n  return (\n    <div data-testid=\"metrics-drilldown-embedded-label-breakdown\">\n      {error ? <ErrorView error={error} /> : <Trail trail={trail} />}\n    </div>\n  );\n};\n\nexport default KnowledgeGraphSourceMetrics;\n","import { dateMath } from '@grafana/data';\nimport { SceneTimeRange } from '@grafana/scenes';\n\ntype MathStringOrUnixTimestamp = string | number;\n\n/**\n * Convert a time string or unix timestamp to a SceneTimeRange.\n *\n * @param time - The time string or unix timestamp.\n * @returns The SceneTimeRange.\n *\n * @example\n * ```ts\n * toSceneTime('now-1h')\n * ```\n *\n * @example\n * ```ts\n * toSceneTime(1723756800000)\n * ```\n */\nfunction toSceneTime(time: MathStringOrUnixTimestamp): string {\n  if (typeof time === 'string' && dateMath.isMathString(time)) {\n    // 'now', 'now-1h', etc.\n    return time;\n  }\n\n  return dateMath.toDateTime(new Date(time), { roundUp: false })!.toISOString();\n}\n\n/**\n * Convert a time string or unix timestamp to a SceneTimeRange.\n *\n * @param from - The start time.\n * @param to - The end time.\n * @returns The SceneTimeRange.\n *\n * @example\n * ```ts\n * toSceneTimeRange('now-1h', 'now')\n * ```\n *\n * @example\n * ```ts\n * toSceneTimeRange(1723756800000, 1723756800000)\n * ```\n *\n * @example\n * ```ts\n * toSceneTimeRange('now-1h', 1723756800000)\n * ```\n */\nexport function toSceneTimeRange(from: MathStringOrUnixTimestamp, to: MathStringOrUnixTimestamp): SceneTimeRange {\n  return new SceneTimeRange({ from: toSceneTime(from), to: toSceneTime(to) });\n}\n"],"names":["extractMetricPrefix","metricName","match","query","initialStart","initialEnd","dataSource","sourceMetrics","error","useCatchExceptions","initRef","useRef","hasSourceMetrics","length","useEffect","current","reportExploreMetrics","component","parsedPromQLQuery","parsePromQLQuery","metric","initialFilters","labels","map","label","labelMatcherToAdHocFilter","err","Error","logger","ErrorView","prefixesToExclude","sourceMetricPrefixes","metricNames","prefixes","Set","Array","from","extractUniquePrefixes","m","filter","every","excludedPrefix","startsWith","undefined","prefixUrlParam","embeddedTrailNamespace","metricFilters","prefix","locationService","partial","join","sortByUrlParam","VAR_WINGMAN_SORT_BY","trail","newMetricsTrail","initialDS","uid","$timeRange","toSceneTimeRange","embedded","div","data-testid","Trail","toSceneTime","time","dateMath","isMathString","toDateTime","Date","roundUp","toISOString","to","SceneTimeRange"],"sourceRoot":""}